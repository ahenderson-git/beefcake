warning: in the working copy of 'src-frontend/renderers.ts', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/tauri_app.rs', LF will be replaced by CRLF the next time Git touches it
diff --git a/capabilities/default.json b/capabilities/default.json
index b5351a6..6d3cf66 100644
--- a/capabilities/default.json
+++ b/capabilities/default.json
@@ -44,6 +44,15 @@
     "allow-generate-powershell",
     "allow-pipeline-from-configs",
     "allow-list-pipeline-templates",
-    "allow-load-pipeline-template"
+    "allow-load-pipeline-template",
+    "allow-dictionary-load-snapshot",
+    "allow-dictionary-list-snapshots",
+    "allow-dictionary-update-business-metadata",
+    "allow-dictionary-export-markdown",
+    "allow-watcher-get-state",
+    "allow-watcher-start",
+    "allow-watcher-stop",
+    "allow-watcher-set-folder",
+    "allow-watcher-ingest-now"
   ]
 }
diff --git a/src-frontend/components/AnalyserComponent.ts b/src-frontend/components/AnalyserComponent.ts
index a087790..5baff0c 100644
--- a/src-frontend/components/AnalyserComponent.ts
+++ b/src-frontend/components/AnalyserComponent.ts
@@ -236,6 +236,24 @@ export class AnalyserComponent extends Component {
     document.getElementById('btn-continue-advanced')?.addEventListener('click', async () => {
       await this.handleContinueToAdvanced(state);
     });
+
+    // Cleaning info box toggle
+    const cleaningInfoHeader = document.querySelector('.cleaning-info-header');
+    if (cleaningInfoHeader) {
+      cleaningInfoHeader.addEventListener('click', () => {
+        const infoBox = document.querySelector('.cleaning-info-box');
+        infoBox?.classList.toggle('collapsed');
+      });
+    }
+
+    // Handle link to reference page in cleaning info box
+    const cleaningInfoLink = document.querySelector('.cleaning-info-link');
+    if (cleaningInfoLink) {
+      cleaningInfoLink.addEventListener('click', (e) => {
+        e.preventDefault();
+        this.actions.navigate('reference');
+      });
+    }
   }

   private async handleExport(state: AppState) {
diff --git a/src-frontend/main.ts b/src-frontend/main.ts
index d6b3e12..af73b40 100644
--- a/src-frontend/main.ts
+++ b/src-frontend/main.ts
@@ -74,6 +74,7 @@ import { LifecycleComponent } from './components/LifecycleComponent';
 import { LifecycleRailComponent } from './components/LifecycleRailComponent';
 import { PipelineComponent } from './components/PipelineComponent';
 import { WatcherComponent } from './components/WatcherComponent';
+import { DictionaryComponent } from './components/DictionaryComponent';

 /**
  * Main application controller for Beefcake frontend.
@@ -246,7 +247,8 @@ class BeefcakeApp {
       'Reference': new ReferenceComponent('view-container', actions),
       'Lifecycle': new LifecycleComponent('view-container', actions),
       'Pipeline': new PipelineComponent('view-container', actions),
-      'Watcher': new WatcherComponent('view-container', actions)
+      'Watcher': new WatcherComponent('view-container', actions),
+      'Dictionary': new DictionaryComponent('view-container', actions)
     };

     // Initialize lifecycle rail component
@@ -262,10 +264,10 @@ class BeefcakeApp {
     });
   }

-  private switchView(view: View) {
+  private async switchView(view: View) {
     this.state.currentView = view;
     this.state.isAddingConnection = false;
-
+
     document.querySelectorAll('.nav-item').forEach(item => {
       item.classList.toggle('active', (item as HTMLElement).dataset.view === view);
     });
@@ -278,9 +280,18 @@ class BeefcakeApp {
       else if (view === 'SQL') title.innerText = 'SQL IDE';
       else if (view === 'Reference') title.innerText = 'Reference Material';
       else if (view === 'Lifecycle') title.innerText = 'Dataset Lifecycle';
+      else if (view === 'Dictionary') title.innerText = 'Data Dictionary';
       else title.innerText = view;
     }

+    // Load snapshots when switching to Dictionary view
+    if (view === 'Dictionary') {
+      const dictionaryComponent = this.components['Dictionary'] as DictionaryComponent;
+      if (dictionaryComponent) {
+        await dictionaryComponent.loadSnapshots();
+      }
+    }
+
     this.render();
   }

diff --git a/src-frontend/renderers.ts b/src-frontend/renderers.ts
index c3fac6d..120e2ad 100644
--- a/src-frontend/renderers.ts
+++ b/src-frontend/renderers.ts
@@ -9,3 +9,4 @@ export * from './renderers/reference';
 export * from './renderers/layout';
 export * from './renderers/cli';
 export * from './renderers/lifecycle';
+export * from './renderers/dictionary';
diff --git a/src-frontend/renderers/analyser.ts b/src-frontend/renderers/analyser.ts
index eacfcb4..f65b73c 100644
--- a/src-frontend/renderers/analyser.ts
+++ b/src-frontend/renderers/analyser.ts
@@ -2,6 +2,55 @@ import { AnalysisResponse, ColumnCleanConfig, ColumnSummary, LifecycleStage } fr
 import { escapeHtml, fmtBytes, fmtDuration } from "../utils";
 import { CASE_OPTIONS, IMPUTE_OPTIONS, NORM_OPTIONS, renderSelect, ROUND_OPTIONS } from "./common";

+function renderCleaningInfoBox(): string {
+  return `
+    <div class="cleaning-info-box">
+      <div class="cleaning-info-header">
+        <i class="ph ph-info"></i>
+        <h4>What does cleaning include?</h4>
+        <button class="cleaning-info-toggle" aria-label="Toggle info">
+          <i class="ph ph-caret-up"></i>
+        </button>
+      </div>
+      <div class="cleaning-info-content">
+        <p class="cleaning-info-intro">The Cleaning stage applies <strong>reversible text and type transformations</strong> to prepare your data:</p>
+        <div class="cleaning-info-grid">
+          <div class="cleaning-info-section">
+            <strong><i class="ph ph-text-t"></i> Text Cleaning:</strong>
+            <ul>
+              <li>Trim whitespace</li>
+              <li>Convert case (lower/upper/title)</li>
+              <li>Remove special characters</li>
+              <li>Standardize null representations</li>
+            </ul>
+          </div>
+          <div class="cleaning-info-section">
+            <strong><i class="ph ph-swap"></i> Type Casting:</strong>
+            <ul>
+              <li>Convert to Numeric, Text, Boolean</li>
+              <li>Parse Temporal (dates/times)</li>
+              <li>Detect Categorical patterns</li>
+            </ul>
+          </div>
+          <div class="cleaning-info-section">
+            <strong><i class="ph ph-tag"></i> Column Renaming:</strong>
+            <ul>
+              <li>Standardize column names</li>
+              <li>Apply custom naming conventions</li>
+            </ul>
+          </div>
+        </div>
+        <p class="cleaning-info-note">
+          <i class="ph ph-arrow-counter-clockwise"></i>
+          <strong>Note:</strong> All cleaning operations in this stage are reversible.
+          Advanced operations (imputation, normalization, encoding) are available in the <strong>Advanced</strong> stage.
+          <a href="#" class="cleaning-info-link" data-view="reference">View full documentation â†’</a>
+        </p>
+      </div>
+    </div>
+  `;
+}
+
 export function renderAnalyserHeader(
   response: AnalysisResponse,
   currentStage: LifecycleStage | null = null,
@@ -25,6 +74,7 @@ export function renderAnalyserHeader(
         </div>
       </div>
     ` : ''}
+    ${currentStage === 'Cleaned' && !isReadOnly ? renderCleaningInfoBox() : ''}
     <div class="analyser-header">
       <div class="header-main">
         <h2>${escapeHtml(response.file_name)} <small>(${fmtBytes(response.file_size)})</small></h2>
diff --git a/src-frontend/renderers/layout.ts b/src-frontend/renderers/layout.ts
index 32211f5..31eafba 100644
--- a/src-frontend/renderers/layout.ts
+++ b/src-frontend/renderers/layout.ts
@@ -22,6 +22,9 @@ export function renderLayout(): string {
           <button class="nav-item" data-view="Watcher">
             <i class="ph ph-eye"></i> Watcher
           </button>
+          <button class="nav-item" data-view="Dictionary">
+            <i class="ph ph-book-open"></i> Dictionary
+          </button>
           <button class="nav-item" data-view="PowerShell">
             <i class="ph ph-terminal"></i> PowerShell
           </button>
diff --git a/src-frontend/types.ts b/src-frontend/types.ts
index 48958ef..588eee1 100644
--- a/src-frontend/types.ts
+++ b/src-frontend/types.ts
@@ -116,7 +116,7 @@ export interface AuditEntry {
   details: string;
 }

-export type View = "Dashboard" | "Analyser" | "PowerShell" | "Python" | "SQL" | "Settings" | "CLI" | "ActivityLog" | "Reference" | "Lifecycle" | "Pipeline" | "Watcher";
+export type View = "Dashboard" | "Analyser" | "PowerShell" | "Python" | "SQL" | "Settings" | "CLI" | "ActivityLog" | "Reference" | "Lifecycle" | "Pipeline" | "Watcher" | "Dictionary";

 // Dataset Lifecycle Types
 export type LifecycleStage = "Raw" | "Profiled" | "Cleaned" | "Advanced" | "Validated" | "Published";
diff --git a/src/tauri_app.rs b/src/tauri_app.rs
index 923cfe9..f9ce7ee 100644
--- a/src/tauri_app.rs
+++ b/src/tauri_app.rs
@@ -763,8 +763,14 @@ pub async fn list_pipeline_templates() -> Result<String, String> {
     // Get templates directory
     let templates_dir = PathBuf::from("data").join("pipelines").join("templates");

+    // Debug: log the path we're looking for
+    eprintln!("[DEBUG] Looking for templates in: {:?}", templates_dir);
+    eprintln!("[DEBUG] Absolute path: {:?}", templates_dir.canonicalize());
+    eprintln!("[DEBUG] Templates directory exists: {}", templates_dir.exists());
+
     // Create directory if it doesn't exist
     if !templates_dir.exists() {
+        eprintln!("[DEBUG] Creating templates directory");
         fs::create_dir_all(&templates_dir)
             .map_err(|e| format!("Failed to create templates directory: {e}"))?;
     }
@@ -773,22 +779,52 @@ pub async fn list_pipeline_templates() -> Result<String, String> {
     let mut templates = Vec::new();

     if let Ok(entries) = fs::read_dir(&templates_dir) {
+        eprintln!("[DEBUG] Successfully opened templates directory");
         for entry in entries.flatten() {
             let path = entry.path();
+            eprintln!("[DEBUG] Found file: {:?}", path);
             if path.extension().and_then(|s| s.to_str()) == Some("json") {
+                eprintln!("[DEBUG] File is JSON, attempting to load: {:?}", path);
                 // Try to load template to get metadata
-                if let Ok(spec) = beefcake::pipeline::PipelineSpec::from_file(&path) {
+                match beefcake::pipeline::PipelineSpec::from_file(&path) {
+                    Ok(spec) => {
+                        eprintln!("[DEBUG] Successfully loaded spec: {}", spec.name);
+                    let metadata = entry.metadata().ok();
+                    let created = metadata
+                        .as_ref()
+                        .and_then(|m| m.created().ok())
+                        .map(|t| chrono::DateTime::<chrono::Utc>::from(t).to_rfc3339())
+                        .unwrap_or_default();
+                    let modified = metadata
+                        .as_ref()
+                        .and_then(|m| m.modified().ok())
+                        .map(|t| chrono::DateTime::<chrono::Utc>::from(t).to_rfc3339())
+                        .unwrap_or_default();
+
                     let info = serde_json::json!({
                         "name": spec.name,
                         "path": path.to_string_lossy(),
+                        "created": created,
+                        "modified": modified,
                         "step_count": spec.steps.len(),
                     });
                     templates.push(info);
+                    }
+                    Err(e) => {
+                        eprintln!("[DEBUG] Failed to load spec: {:?}", e);
+                        eprintln!("[DEBUG] Full error chain:");
+                        for cause in e.chain() {
+                            eprintln!("[DEBUG]   - {}", cause);
+                        }
+                    }
                 }
             }
         }
+    } else {
+        eprintln!("[DEBUG] Failed to read templates directory");
     }

+    eprintln!("[DEBUG] Found {} templates", templates.len());
     serde_json::to_string(&templates)
         .map_err(|e| format!("Failed to serialize templates: {e}"))
 }